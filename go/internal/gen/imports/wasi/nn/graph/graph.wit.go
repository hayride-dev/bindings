// Code generated by wit-bindgen-go. DO NOT EDIT.

// Package graph represents the imported interface "wasi:nn/graph@0.2.0-rc-2024-10-28".
//
// A `graph` is a loaded instance of a specific ML model (e.g., MobileNet) for a specific
// ML
// framework (e.g., TensorFlow):
package graph

import (
	"github.com/hayride-dev/bindings/go/internal/gen/imports/wasi/nn/errors"
	"github.com/hayride-dev/bindings/go/internal/gen/imports/wasi/nn/inference"
	"github.com/hayride-dev/bindings/go/internal/gen/imports/wasi/nn/tensor"
	"go.bytecodealliance.org/cm"
)

// Error represents the imported type alias "wasi:nn/graph@0.2.0-rc-2024-10-28#error".
//
// See [errors.Error] for more information.
type Error = errors.Error

// Tensor represents the imported type alias "wasi:nn/graph@0.2.0-rc-2024-10-28#tensor".
//
// See [tensor.Tensor] for more information.
type Tensor = tensor.Tensor

// GraphExecutionContext represents the imported type alias "wasi:nn/graph@0.2.0-rc-2024-10-28#graph-execution-context".
//
// See [inference.GraphExecutionContext] for more information.
type GraphExecutionContext = inference.GraphExecutionContext

// Graph represents the imported resource "wasi:nn/graph@0.2.0-rc-2024-10-28#graph".
//
// An execution graph for performing inference (i.e., a model).
//
//	resource graph
type Graph cm.Resource

// ResourceDrop represents the imported resource-drop for resource "graph".
//
// Drops a resource handle.
//
//go:nosplit
func (self Graph) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_GraphResourceDrop((uint32)(self0))
	return
}

// InitExecutionContext represents the imported method "init-execution-context".
//
//	init-execution-context: func() -> result<graph-execution-context, error>
//
//go:nosplit
func (self Graph) InitExecutionContext() (result cm.Result[GraphExecutionContext, GraphExecutionContext, Error]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_GraphInitExecutionContext((uint32)(self0), &result)
	return
}

// GraphEncoding represents the enum "wasi:nn/graph@0.2.0-rc-2024-10-28#graph-encoding".
//
// Describes the encoding of the graph. This allows the API to be implemented by various
// backends that encode (i.e., serialize) their graph IR with different formats.
//
//	enum graph-encoding {
//		openvino,
//		onnx,
//		tensorflow,
//		pytorch,
//		tensorflowlite,
//		ggml,
//		autodetect
//	}
type GraphEncoding uint8

const (
	GraphEncodingOpenvino GraphEncoding = iota
	GraphEncodingOnnx
	GraphEncodingTensorflow
	GraphEncodingPytorch
	GraphEncodingTensorflowlite
	GraphEncodingGgml
	GraphEncodingAutodetect
)

var stringsGraphEncoding = [7]string{
	"openvino",
	"onnx",
	"tensorflow",
	"pytorch",
	"tensorflowlite",
	"ggml",
	"autodetect",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e GraphEncoding) String() string {
	return stringsGraphEncoding[e]
}

// ExecutionTarget represents the enum "wasi:nn/graph@0.2.0-rc-2024-10-28#execution-target".
//
// Define where the graph should be executed.
//
//	enum execution-target {
//		cpu,
//		gpu,
//		tpu
//	}
type ExecutionTarget uint8

const (
	ExecutionTargetCPU ExecutionTarget = iota
	ExecutionTargetGpu
	ExecutionTargetTpu
)

var stringsExecutionTarget = [3]string{
	"cpu",
	"gpu",
	"tpu",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e ExecutionTarget) String() string {
	return stringsExecutionTarget[e]
}

// GraphBuilder represents the list "wasi:nn/graph@0.2.0-rc-2024-10-28#graph-builder".
//
// The graph initialization data.
//
// This gets bundled up into an array of buffers because implementing backends may
// encode their
// graph IR in parts (e.g., OpenVINO stores its IR and weights separately).
//
//	type graph-builder = list<u8>
type GraphBuilder cm.List[uint8]

// Load represents the imported function "load".
//
// Load a `graph` from an opaque sequence of bytes to use for inference.
//
//	load: func(builder: list<graph-builder>, encoding: graph-encoding, target: execution-target)
//	-> result<graph, error>
//
//go:nosplit
func Load(builder cm.List[GraphBuilder], encoding GraphEncoding, target ExecutionTarget) (result cm.Result[Graph, Graph, Error]) {
	builder0, builder1 := cm.LowerList(builder)
	encoding0 := (uint32)(encoding)
	target0 := (uint32)(target)
	wasmimport_Load((*GraphBuilder)(builder0), (uint32)(builder1), (uint32)(encoding0), (uint32)(target0), &result)
	return
}

// LoadByName represents the imported function "load-by-name".
//
// Load a `graph` by name.
//
// How the host expects the names to be passed and how it stores the graphs for retrieval
// via
// this function is **implementation-specific**. This allows hosts to choose name
// schemes that
// range from simple to complex (e.g., URLs?) and caching mechanisms of various kinds.
//
//	load-by-name: func(name: string) -> result<graph, error>
//
//go:nosplit
func LoadByName(name string) (result cm.Result[Graph, Graph, Error]) {
	name0, name1 := cm.LowerString(name)
	wasmimport_LoadByName((*uint8)(name0), (uint32)(name1), &result)
	return
}
